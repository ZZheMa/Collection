LESSON 1
1.大学学习，不但要学习基础知识，更要培养思维能力。

2.两遍编译过程（two-pass compiling）
大部分编程语言采用单遍编译过程，但C和C++语言却都采用两遍编译过程：
（1）第一遍（first pass）：
将源程序文件编译为汇编语言文件，汇编语言文件名称的后缀为 asm等。一般编程人员不使用这类文件。
调试程序时如果希望阅读汇编语言文件，可以在调试中将VC++的菜单项“view”下拉，
在子菜单“Debug Windows”中选择最后一项“Disassembly”（热键为Alt+8），即可看到汇编语言文件。
（2）第二遍（second pass）：
将汇编语言文件编译为目标文件（object files），目标文件名称的后缀为 obj。


LESSON 2
1.系统地学习一下英语语法，不需要很深入，一定要系统的去学习。

2.英语精读很有用，不要不求甚解，精读要一句一句地就理解，去翻译，读一句去理解一句，而不是走马观花
地看了很多，其实不是很理解，那样进步很慢。
精读之后然后泛读，扩大词汇，巩固语法。

3.高水平的英语学习，要有英语思维，不经过大脑即可脱口而出。


LESSON 3
1.在正常编译过程之前作为预备动作而执行，编译过程结束后不占用存储空间。

2.宏和函数的区别：宏节省时间但是占用空间，函数节省空间但是增加时间。

3.头文件用<>包括起来，系统就根据这点到系统的文件夹中去调用，
用双引号""包括起来，系统就根据这点到用户程序的文件夹中去调用。

LESSON 4
1.int arr[10];
arr是一个数组名，又是数组首地址，也是一个数组指针且为常量指针(int* const arr)，因为
arr为常量指针，所以其不允许重新赋值，例如arr++是错误的。如果arr不为常量指针，那么这个
数组在栈中开辟出来后，就不能永远有效地使用它。

2.char *nm = "Nice";
char name[] = "OK";
"OK"在栈区，"Nice"在数据区。

3.指针数组，全是指针的一个数组，
char* name[] = {" ","Monday","Tuesday","Wednesday","Thursday", "Friday", "Saturday", "Sunday"};
数组指针，一个数组的指针，
char (*name)[];

4.函数指针
void Fun();
int main() {
  void (*ptr)() = Fun;
}
函数指针数组
void (*ptr[])() = { Fun1, Fun2, Fun3 };


LESSON 5
1.引用是“别名其表，指针其实”。引用的类型必须和变量的类型一样，引用实质上是一个指针，
引用完全具有指针的功能。
eg：
void main() {
  int i = 4;
  int j = 8;
  int& r = i; 
}
栈区内存地址     变量内容
0X0065FDF4       i = 4
OX0065FDF0       j = 8
0X0065FDEC       i的引用r，内容为地址0X0065FDF4，也就是i的地址。

从上述的例子可以看到，引用不占用空间是错误的说法，引用实际上就是指针。
引用一经初始化后，就不能重新指向其它的变量，即所存储的地址值不能那个再次更改。

但是人们并不能拿到引用这个指针的地址，C++语法使其操作起来就像操作原来的变量一样，
语法层面将其指针的特性进行了隐藏。但是编译器对其实现时，将其处理为指针。C++这样做的
好处使用户用起指针来更加方便。

2.函数调用过程：
void Swap();
void main() {
  int a;
  int b;
  Swap(a, b);
}
A.保存调用程序（function caller，此处即main()）在调用子函数swap( )时的地址，即返主地址，
将其压入栈内，以便在调用子函数swap的操作结束之后返回原地。
B.将函数返回值以及实参复制为副本(copy)后压入栈内，以便代替形参来参加函数的运行。
C.将函数运行时将要使用的各寄存器（主要是EBP、EBX、ESI和EDI）的内容压入栈内，加以保存。现场保护。
D.执行被调用函数swap()的函数体内的全部语句。
E.如函数有返回值，则将该返回值写入寄存器EAX内,通过它传递给调用函数的程序（即main()）。
F将各寄存器内容弹出栈，释放被占栈空间,恢复调用函数的程序的运行状态。回复现场。
G.按照返主地址将控制权交还给调用函数（即main()）。

3.void
A.void变量是“什么变量都没有”。
B.void fun();表示函数fun不返回任何变量。
C.void指针表示“任何类型的指针”。
D.void fun(void*);表示函数fun的形参可以是任何类型的指针。

4.new与malloc相比的优点是：
A.new能够按照变量类型自动的分配该类型所需空间长度，不必使用sizeof。
B.new能够返回正确的指针类型。
C.new出来的对象会自动调用对象的构造函数，将对象初始化。


LESSON 6
1.堆区块的结构。
每当调用运算符new在堆区块内分配空间时，系统就为用户分配一个堆区块。该区块包括首部域
和用户数据两个域。首部域存放管理数据，用户数据域存放用户数据。首部域的长度是固定的，
32个字节，用于存放8个管理数据，每个数据都是一个整形变量。用户数据长度是变动的，不小于
用户数据的长度，其最短字节为16字节。为了方便管理，它的长度按照16字节递增。而new返回来
的指针指向的是用户数据域名的首地址。首部域的八个管理数据包括链表首位结点的首地址，
用户数据长度，用户堆区块数量，该区块的序号等。

2.堆区块的建立和管理。
所分配的堆区块空间按照双向链表（包含前向链表和后向链表）进行管理。每当系统函数
或者用户函数调用new申请分配堆区空间时，系统即建立一个堆区块，形成新结点，
将其插入到前向链表的前端，形成前向链表的首结点。
eg：
void main() {
  int* ptr1 = new int(10);  // 初始化为10，并不是长度为10的数组。
  double* ptr2 = new double(12.34);
  int* ptr3 = new int[3];
  
  // 读取第一个堆区块
  int* show = ptr1 - 8;  // 移动指针到堆区块的首部域的第一个数据的地址。
  for (int j = 1; j < 9; ++j) {
    cout << "Element " << j << " address : " << show;
	cout << "  Value : " << *show++ << endl;
  }
  // 读取第二块和第三块堆区块的数据。可以通过里面的首部域数据，将这三个结点连接起来。
}

3.new operator 和operator new。
http://blog.csdn.net/wudaijun/article/details/9273339

A.new operator: 指我们在C++里面通常用到的关键字。
eg:
A* a = new A;
delete a;
这个操作第一步分配内存。第二步调用A的构造函数初始化对象。第三步返回分配指针。
事实上分配内存就是有operator new(size_t)来完成的，如果类A重载了operator new，
那么将调用A::operator new(size_t),否则调用C++默认提供的operator new(size_t)。
delete a这一操作也类似，包含了调用析构函数和operator delete(size_t)两个步骤。

B.operator new: 它指一个操作符，并且可被重载。operator new就象 malloc 一样，
operator new 的职责只是分配内存，它对构造函数一无所知。
A* a = (A*)operator new(sizeof(A));

operator new有三种形式：
throwing (1)    
void* operator new (std::size_t size) throw (std::bad_alloc);
nothrow (2) 
void* operator new (std::size_t size, const std::nothrow_t& nothrow_value) throw();
placement (3)   
void* operator new (std::size_t size, void* ptr) throw();

(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。
它们都分配一个固定大小的连续内存。
A* a = new A; //调用throwing(1)
A* a = new(std::nothrow) A; //调用nothrow(2)
(3)是placement new，它也是对operator new的一个重载，定义于#include <new>中，它多接收一个ptr参数，
但它只是简单地返回ptr。它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。 

4.变量的两个基本属性：生命周期和作用域。

5.所有静态变量在使用前必须加以定义，它们被定义时即自动被初始化，具有缺省值为零，
这一点与全局变量（外部变量）相同。因此，对于int型静态变量用0值初始化是多余的。
 
 
LESSON 7
1.本课程中所有的地址都是虚拟地址，即在该程序所分配到的内存中的相对地址，这
并不代表内存中的真实地址（绝对地址）。
内存很大，操作系统只是拿出一小部分给程序用。

2.对象的数据存储空间分为两部分：栈区和数据区，数据区用于存放静态变量，栈区存放该对象的非
静态数据。代码区存放成员函数的代码，如果类中包含虚函数，则栈区还存放该对象的虚指针，数据区
存放该对象的虚地址。

3.类的接口部分与实现部分的分离：对用户而言，他们只关心类的接口，只要类的功能不变，也就是类的
接口不变，所以无论类的实现部分如何改变都不影响用户，也不需要修改用户程序。
用户调用类的成员函数时不须了解类的源代码（即成员函数的定义），而只须了解类的功能也即类
的接口即可。因此用户在使用时只须将已经该动过的类的实现[方法]的目标代码连接在用户程序之内即可。
软件供应商提供头文件和各隐藏文件的目标代码模块（即目标文件），以供用户用于编写各种用户程序。

4.将类接口的重要信息放在头文件中而将不希望用户了解的信息（类的实现[方法]部分）
放在不公开发表的源文件（以下称为隐藏源文件）中，这符合最低权限原则。

5.描述类的功能而不谈其实现细节的做法，有人称为数据抽象（data abstraction），
有人称之为数据隐藏。






