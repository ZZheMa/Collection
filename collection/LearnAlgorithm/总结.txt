方法总结：
1. 长短指针法
2. 去模拟结果，看看是否能达到和预期的一样。例如判断出栈顺序是否正确。
3. 将一个数据结构分为多段来实现效率，例如求中位数，把一组数分为两个堆。
4. 链表中巧用空的头结点，使得操作更加方便，不用考虑特殊情况。
5. 堆，也就是优先队列，快速找到最大值和最小值。灵活应用提高效率。例如求数组中第k大的值。
6. 保存每一个状态的值，使得时间复杂度为O(1)。例如min_stack。

7. 对于数列问题，或者说链表等，找一组数的规律，可以采用数形结合的思路，例如题16（最长摆动子序列），就利用数形结合将其抽象为求
极值点的问题。
8. 巧妙使用状态机，例如可以求极值点。有明显的状态转换问题，可以考虑用状态机。
9. 贪心算法更多的使找规律，不完全归纳法。也就是说先从一个开始找规律，使得第一个成为最优解，也就是局部最优解，
然后逐步向后扩散，也就是每步都是最优解，那么最终结果也就是最优解。
10. 贪心的算法就是找规律，从对简单的情况开始试探，这是找规律的最好方法。
11. 数形结合：18射击气球
12. 保存中间态，更方便分析问题：19跳跃游戏1

13. 巧用真值表来列举所有的情况，每一个比特位0和1代表该位的数是否存在。例如（23求一组数的所有子集2）。
14. 巧用数据结构set来去重，set的查找效率更高。例如24求不重复的所有子集
15. 计算组合数之前，可以先将给定数组排序，这样就能避免一个问题：两个子集里面的元素相同，但是顺序不一样，
例如 {1, 2, 1} 和 {1, 1, 2}，这两个子集里面的元素一样，但是顺序不一样。排序之后在计算组合数则不会出现这样的状况。
例如24求不重复的所有子集。
16. 二叉树递归遍历的变形，例如26生成所有正确括号。

17. 二维数组中向量的使用：例如（27N皇后问题）(x,y)这个点上下左右斜对角八个点，相对于x的偏移量。（X,Y）= N(dx,dy) + (x,y)。
18. 回溯法的求解过程实质上是一个先序遍历一棵状态树的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历的过程中。
所以解答此类题的关键就是找到这棵树，然后将题目转化为遍历树的过程。
19. 比较27和28两道递归题的区别，一个有返回值，一个没有。
20. 对于递归在题目中提前找到剪枝条件十分重要。例如27题。
21. 通过对原始数据进行排序来减少递归的次数，例如27题。
22. 位运算法：对于求解给定数组的某种组合使用该方法十分便利。0和1分别代表数组某一位是否选择。例如两个数则有四种组合，
用数字表示这四种组合也就是0,1,2,3。用一个数就能表示一个子集，十分巧妙。然后可以巧妙利用位运算符以及移位操作。
例如（28火柴摆正方形）（23求一组数的所有子集2）。

23.巧妙使用二分法查找，对于排序的一组数，如果进行查找操作，二分法可以考虑。（31查找某个数的区间）

33.充分理解树的先序，中序，后序遍历。先序：先根节点，然后左右节点。中序：先左节点，然后根节点，最后右节点。
后序：先左右节点，然后根节点（33找到和为某数的数的路径）

34.分治思想的使用，将K个大规模数据分成N个小规模的同性质的数据进行处理，然后进行合并。有递归写法和循环写法，
参考（34合并k个升序链表.cpp），（29归并排序）（35逆序数）。

