第一天
1.sizeof 一个对象，求得的数据部分的尺寸，而不求代码（也就是函数）的尺寸。
一个对象数据和函数是分开存储的，有数据段，代码段等。涉及到C++对象模型的知识。
这样的设计即多份数据共用一份代码（函数）只适用于单cpu执行的情况。一个CPU一次只能执行一条指令，所以每个对象都有自己的函数代码
所生成的指令是没用的，因为cpu每次只能执行一条指令，也就是只能访问一个对象的指令。但是这样的对象模型如果是并行计算则会出现问题。
例如对象A在CPU1里面跑，对象B在CPU2里面跑，那么编译器只生成一份函数指令则会出现问题，因为两个对象要同时执行这个指令，即两个CPU
的程序指针同时指向该函数指令所在的内存。设计到并行机的知识。


第二天
1.一个类声明和实现分别写到头文件和源文件中，这样成员函数是非inline的。声明时用inline修饰就可以使该成员函数成为inline的。
如果一个类声明和实现写在一起，也就是在类里面直接写实现，这样成员函数是inline的。

2.C语言函数是禁止嵌套定义，必须嵌套调用。

第三天
1.静态先于main函数的执行而存在。

2.所有计算机理论在杨力祥看来不外乎两个词：序和可识别。

3.数据结构的那些设计就是由于硬件的设计所导致的，物质基础决定上层建筑。

4.鉴赏力：例如拿一本书翻几页，知道它要实现个什么东西，然后合上书，自己去思考，
去设计。自己设计完之后，再打开书和别人的去对比，这样就能发现大师设计的想法是多么优秀。
可以看到自己跟大师的差距。学东西最怕的就是学了十几二十年看不到自己和别人差在哪里。
一个人有没有水平就体现在鉴赏力上面，能不能看出它好在哪里。

5.用体系性思维去思考问题，把一个东西放到体系里面去思考。

6.C语言调用函数时将局部变量压栈出栈，那么如果将所有的局部变量都定义为静态可以吗？
不难发现静态全局的访问速度更快，而压栈还需要不断的进栈出栈。栈是动态使用内存，
静态变量是静态使用内存，也就是编译器已经算好它的大小及数量等。如果将局部变量定义为静态，
所有的情况都可以解决，但是有一个问题解决不了，就是自己调用自己，或者说递归。
说明C语言在设计时，递归在整个体系结构中占了很重要的地位。

7.指针是地址吗？如果指针是地址为什么还要起这么个名字，直接叫地址不就好了。
在计算机里指针主要分为两大类，一个是指令指针，也就是程序指针，另一个就是数据指针，
数据指针往往用寄存器来代替。指针就是一个指向数据的地址吗？在计算机中每个字节就是一个地址，
但是一个数据不一定只占有一个地址。指针指向的是一个数据的首地址，且指针是有类型的。当拿到一个指针的时候，
也就是拿到了一个数据的首地址，拿到首地址后应该向下数几个字节来拼成这个数据，就由指针的类型确定，
拼成这个数据之后，编译器如何解析这个数据，例如4个字节，该解析为int还是float，这个也由指针的类型来确定。
 
8.指针的三个优点。第一，以小搏大。即就地解决，山不过来，我过去的思想。用于函数传参时传址。
传参时不把所有数据都带过去，复制一遍，而是将所有数据的内存地址传过去。
第二，切换。指令的切换，函数指针，也就是指令指针，例如动态链接库，用指针在动态链接库里来回切换函数，
调用里面的各种函数。数据的切换，数组不是一个类型，只是一个组数据的打包。数据的切换例如数组中的行指针列指针的应用。
第三，就是挂接，最常用的挂接就是链表。用指针把一组数据连接起来。

9.指令指针寄存器IP（X86型CPU）相当于ARM型CPU中的程序计数器PC。

10.IP在main函数指令执行中遇到调用函数，也就是跳转指令，跳转到另一个函数的指令位置，然后开始
执行，执行完该函数的指令之后，IP又跳回到原来main函数指令的位置。CPU中有一大堆寄存器用来计算等。
当调用函数IP还没跳转时，CPU中的寄存器存储的是现在正在计算的那些数据，也就是跳转前的状态。但是
IP跳转之后，CPU开始做新的是事情，也就是CPU中的寄存器开始处理新的计算，而跳转前正在处理数据寄存器
的值就会丢失。当该函数调用完之后，IP返回原来的位置，CPU的寄存器也应该会返回到跳转之前的状态，继续
干原来的事情，但是调用函数的时候，CPU的寄存器已经处于调用函数时的状态了。该怎么解决这个问题？
将寄存器的数据进行压栈和出栈，即保护现场和恢复现场。 内存的栈区，其实就是纯粹的数据。
返回值为基本类型的直接走寄存器，而返回值为自定义类型的往栈里走。

11.调用一个函数栈里面存放的东西依次是（由编译器决定）：CPU原来的状态（现场保护），返回值，形参，然后是一些局部变量的数据。
例如在调用函数时，执行char a = 'a';时，实际就是将'a'这个值进行压栈，将这个数据放到栈的内存里面来进行使用。
压栈出栈其实就是一个栈指针的来回走动。调用函数传参，其实就是向栈里面的形参的那块内存直接写一个值，

12.程序是如何运行的？点击一个exe，实在操作系统上运行一个程序，操作系统将exe的一些有效文件从磁盘装载到内存中，
对于C来说装载两类数据，一类是代码，另一类是静态数据。静态数据又分全局变量和静态局部变量。
然后指令指针IP指向main函数入口点的对应位置。然后开始执行。可以发现静态数据是先于main函数的执行而存在，
这也是静态数据的一个巨大的作用，一般而言函数都是在main函数执行之后才能执行，
但是一个全局对象的构造函数是先于main函数的执行而执行的。IP指向main函数入口之后，程序开始执行，也就是IP开始自动往下走，
IP走的方式有两种（有硬件决定），一种是顺序执行（沿着指令的顺序自动往下走，CPU的功能，不需要人为干预），
另一种是跳转（由程序员控制，例如循环（向上跳）和条件判断执行（向下跳））。

13.静态数据在被加载到内存而不是在硬盘上的证明：
int a[N];
int main(){}
build如上程序，将N设置为10000，而1，比较两个程序的可执行文件exe的大小，发现两个文件一样大，也就是说这个静态数据
并不在硬盘上，而是操作系统加载时，开辟到内存的。

第四天
1.c/c++中有一个先声明后使用的原则。
声明（声明变量和函数）是给编译器看的。定义变量时才会开辟内存，声明不会开辟，声明是个编译器看的，如果声明了一个变量，
且后面没有使用，则编译器会将其优化，视为不存在，不会开辟内存。

2.写一个函数的顺序是先声明，再定义，最后调用。但是声明和定义可以合起来写。例如下面的写法：
void Swap(int, int);
void main() {
	Swap(a ,b);
}
void Swap(int x, int y)  {
	int temp = x;
	...
}
首先声明函数Swap是为了给编译器看，知道了其返回值类型和参数类型几个数，只是为了计算其在
栈中占用空间，方便栈指针跳转等（不得而知），所以不用写参数名字，有了其类型就够了。
而定义的时候，是必须要知道参数的名字的，第一因为函数中要用到这个参数。但是问题来了，如果
不写参数名字，调用函数时形参在从左到右一个一个的进栈时，由此每个参数在栈中的内存地址
我都知道了，函数中的使用不就可以直接访问那个地址了吗？这也就导致了第二个原因，函数参数
进栈的顺序是不一定的，所以必须为其加上名字，后面才能准确拿到参数。

3.编译是以*.c或*.cpp文件为单位编译的。一个程序里面有几个cpp编译几次，一个cpp只编译一次。
#include "a.h"是将该文件a.h的内容嵌入到当前位置。例如下面某个文件的代码。
#include "Circle.h"
int main() {
  Circle circle(1, 2);
}
由c/c++先声明后使用的原则，只要在该cpp文件中声明了Circle这个类，就可以使用。所以写上了
#include "Circle.h"这句话，将Circle的声明代码嵌入到当前这个文件。

4.地址重定位：例如在main.c中调用了a.h中的函数，a.h中的函数只声明而不定义，所以
在main.obj中，也就是在main.c编译之后的机器码中，IP跳转到该函数的地址是不知道的，因为该函数的
.obj还没有链接到一起，所以这些调用函数地方指针都空出来了，当所有obj都拼到一起之后，编译器算出
该函数地址的值赋值给原来指针的地方，也就是地址重定位。

5.一个.cpp文件编译之后一般来说生成一个.obj文件（目标文件，机器码，可执行，但不是立即可执行）。
然后将多个编译生成的.obj文件以及标准库等其他的.obj文件拼在一起后，然后进行地址重定位，将
其之间的关系全部联系起来。最后加入一些头等打包成exe。

6.所谓lib库等，就是将一大堆的.obj文件合起来，然后加入一些引导头之类的。

7.上述讲的这些链接，都是静态链接，链接之后还是在硬盘中，执行的时候加载到内存中。
例如printf这个函数的代码，在运行之前已经存在于exe，这就是静态链接。
相对的就是动态链接dll。 

8.链接printf的时候，不是讲"stdio.h"这个库连接进去，而是将printf链接进去，以最简化原则，
需要谁连接谁。

9.静态链接中，例如连续调用多次printf函数，实际上就链接了一次，只产生一份代码，只是传的参数不同。
但是站在操作系统的角度来看，系统中有多个程序在执行，每个程序都调用了printf，也就是每个程序都
链接了一次printf。站在程序的角度看，自己已经很节约了只链接了一次，但是站在操作系统的角度看，
链接了多次，产生了浪费，其实只要搞出一份代码就可以，自己的程序访问别人程序的代码，
但是这样就导致了跨进程的问题，十分不安全。而动态链接库就解决了这个问题。动态链接库没有将代码
放到某个程序中，而是放到操作系统中，当某个程序使用其的时候，应用loadLibrary这个技术，加载该库。
如果要用printf函数，就从dll中找到该函数的地址。原来是静态的算好printf函数的地址，现在变成了动态
获取printf函数的地址。

10.作用域，生存周期。
例如static局部变量，全局的生存周期，局部的作用域。







